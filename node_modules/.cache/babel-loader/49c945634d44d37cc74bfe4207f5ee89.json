{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Also makes nodes point back to their previous node,\n// allowing us to compute the shortest path by backtracking\n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n  let sortIt = true;\n\n  while (!!unvisitedNodes.length) {\n    if (sortIt) {\n      quickSortByDistance(unvisitedNodes, 0, unvisitedNodes.length - 1);\n    }\n\n    const closestNode = unvisitedNodes.shift(); // If the closest node is a wall, skip it\n\n    if (closestNode.isWall) {\n      sortIt = false;\n      continue;\n    } // If the closest node is at a distance of infinity,\n    // we no longer have a way to continue on, therefore we stop\n\n\n    if (closestNode.distance === Number.POSITIVE_INFINITY) {\n      return visitedNodesInOrder;\n    }\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbours(grid, closestNode);\n  }\n}\n\nfunction updateUnvisitedNeighbours(grid, closestNode) {}\n\nfunction quickSortByDistance(array, start, end) {\n  if (start < end) {\n    let partitionIdx = partition(array, start, end);\n    quickSortByDistance(array, start, partitionIdx - 1);\n    quickSortByDistance(array, partitionIdx + 1, end);\n  }\n}\n\nfunction partition(array, start, end) {\n  let pivot = array[end].distance;\n  let partitionIdx = start;\n\n  for (let i = start; i < end; i++) {\n    if (array[i].distance <= pivot) {\n      swap(array, i, partitionIdx);\n      partitionIdx++;\n    }\n  }\n\n  swap(array, partitionIdx, end);\n  return partitionIdx;\n}\n\nfunction swap(array, idx1, idx2) {\n  const temp = array[idx1];\n  array[idx1] = array[idx2];\n  array[idx2] = temp;\n}\n\nfunction getNodes(grid) {\n  nodes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    currentRow = grid[i];\n\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/Users/andreimihai/Documents/proiecteDiverse/proiecte/pathfinding-visualizer/src/Algorithms/Dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","distance","visitedNodesInOrder","unvisitedNodes","getNodes","sortIt","length","quickSortByDistance","closestNode","shift","isWall","Number","POSITIVE_INFINITY","isVisited","push","updateUnvisitedNeighbours","array","start","end","partitionIdx","partition","pivot","i","swap","idx1","idx2","temp","nodes","currentRow","j"],"mappings":"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","sourcesContent":["// Returns all nodes in the order in which they were visited.\n// Also makes nodes point back to their previous node,\n// allowing us to compute the shortest path by backtracking\n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n  let sortIt = true;\n\n  while (!!unvisitedNodes.length) {\n    if (sortIt) {\n      quickSortByDistance(unvisitedNodes, 0, unvisitedNodes.length - 1);\n    }\n\n    const closestNode = unvisitedNodes.shift();\n\n    // If the closest node is a wall, skip it\n    if (closestNode.isWall)  {\n        sortIt = false;\n        continue;\n    }\n\n    // If the closest node is at a distance of infinity,\n    // we no longer have a way to continue on, therefore we stop\n    if (closestNode.distance === Number.POSITIVE_INFINITY) {\n      return visitedNodesInOrder;\n    }\n\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbours(grid, closestNode);\n  }\n}\n\nfunction updateUnvisitedNeighbours(grid, closestNode) {}\n\nfunction quickSortByDistance(array, start, end) {\n  if (start < end) {\n    let partitionIdx = partition(array, start, end);\n    quickSortByDistance(array, start, partitionIdx - 1);\n    quickSortByDistance(array, partitionIdx + 1, end);\n  }\n}\n\nfunction partition(array, start, end) {\n  let pivot = array[end].distance;\n  let partitionIdx = start;\n\n  for (let i = start; i < end; i++) {\n    if (array[i].distance <= pivot) {\n      swap(array, i, partitionIdx);\n      partitionIdx++;\n    }\n  }\n\n  swap(array, partitionIdx, end);\n  return partitionIdx;\n}\n\nfunction swap(array, idx1, idx2) {\n  const temp = array[idx1];\n  array[idx1] = array[idx2];\n  array[idx2] = temp;\n}\n\nfunction getNodes(grid) {\n  nodes = [];\n  for (let i = 0; i < grid.length; i++) {\n    currentRow = grid[i];\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}\n"]},"metadata":{},"sourceType":"module"}