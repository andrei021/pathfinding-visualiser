{"ast":null,"code":"// Returns all nodes in the order in which they were visited. \n// Also makes nodes point back to their previous node, \n// allowing us to compute the shortest path by backtracking \n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    quickSortByDistance(unvisitedNodes, 0);\n  }\n}\n\nfunction quickSortByDistance(unvisitedNodes, start, end) {}\n\nfunction getNodes(grid) {\n  nodes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    currentRow = grid[i];\n\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/Users/andreimihai/Documents/proiecteDiverse/proiecte/pathfinding-visualizer/src/Algorithms/Dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","distance","visitedNodesInOrder","unvisitedNodes","getNodes","length","quickSortByDistance","start","end","nodes","i","currentRow","j","push"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,SAASA,QAAT,CAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCC,UAAnC,EAA+C;AAClDD,EAAAA,SAAS,CAACE,QAAV,GAAqB,CAArB;AACA,QAAMC,mBAAmB,GAAG,EAA5B;AACA,QAAMC,cAAc,GAAGC,QAAQ,CAACN,IAAD,CAA/B;;AAEA,SAAM,CAAC,CAACK,cAAc,CAACE,MAAvB,EAA+B;AAC3BC,IAAAA,mBAAmB,CAACH,cAAD,EAAiB,CAAjB,CAAnB;AACH;AACJ;;AAED,SAASG,mBAAT,CAA6BH,cAA7B,EAA6CI,KAA7C,EAAoDC,GAApD,EAAyD,CAExD;;AAED,SAASJ,QAAT,CAAkBN,IAAlB,EAAwB;AACpBW,EAAAA,KAAK,GAAG,EAAR;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGZ,IAAI,CAACO,MAAxB,EAAgCK,CAAC,EAAjC,EAAqC;AACjCC,IAAAA,UAAU,GAAGb,IAAI,CAACY,CAAD,CAAjB;;AACA,SAAI,IAAIE,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGD,UAAU,CAACN,MAA9B,EAAsCO,CAAC,EAAvC,EAA2C;AACvCH,MAAAA,KAAK,CAACI,IAAN,CAAWF,UAAU,CAACC,CAAD,CAArB;AACH;AACJ;;AAED,SAAOH,KAAP;AACH","sourcesContent":["// Returns all nodes in the order in which they were visited. \n// Also makes nodes point back to their previous node, \n// allowing us to compute the shortest path by backtracking \n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n    startNode.distance = 0;\n    const visitedNodesInOrder = [];\n    const unvisitedNodes = getNodes(grid);\n\n    while(!!unvisitedNodes.length) {\n        quickSortByDistance(unvisitedNodes, 0);\n    }\n}\n\nfunction quickSortByDistance(unvisitedNodes, start, end) {\n\n}\n\nfunction getNodes(grid) {\n    nodes = [];\n    for(let i = 0; i < grid.length; i++) {\n        currentRow = grid[i];\n        for(let j = 0; j < currentRow.length; j++) {\n            nodes.push(currentRow[j]);\n        }\n    }\n\n    return nodes;\n} \n"]},"metadata":{},"sourceType":"module"}