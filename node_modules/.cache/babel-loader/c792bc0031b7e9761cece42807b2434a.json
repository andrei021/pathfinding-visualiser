{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Also makes nodes point back to their previous node,\n// allowing us to compute the shortest path by backtracking\n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n  let sortIt = true;\n\n  while (!!unvisitedNodes.length) {\n    if (sortIt) {\n      quickSortByDistance(unvisitedNodes, 0, unvisitedNodes.length - 1);\n    }\n\n    const closestNode = unvisitedNodes.shift(); // If the closest node is a wall, skip the node and the sorting\n    // since none of the distances have changed\n\n    if (closestNode.isWall) {\n      sortIt = false;\n      continue;\n    } // If the closest node is at a distance of infinity,\n    // we no longer have a way to continue on, therefore we stop\n\n\n    if (closestNode.distance === Number.POSITIVE_INFINITY) {\n      return visitedNodesInOrder;\n    }\n\n    sortIt = true;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbours(grid, closestNode);\n  }\n}\n\nfunction updateUnvisitedNeighbours(grid, node) {\n  const unVisitedNeighbours = getUnvisitedNeighbours(grid, node);\n\n  for (let i = 0; i < unVisitedNeighbours.length; i++) {\n    const neighbour = unVisitedNeighbours[i];\n    neighbour.distance = node.distance + 1;\n    neighbour.prevNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(grid, node) {\n  const unVisitedNeighbours = [];\n  const {\n    row,\n    col\n  } = node;\n\n  if (row > 0 && !grid[row - 1][col].isVisited) {\n    unVisitedNeighbours.push(grid[row - 1][col]);\n  }\n\n  if (col > 0 && !grid[row][col - 1].isVisited) {\n    unVisitedNeighbours.push(grid[row][col - 1]);\n  }\n\n  if (row < grid.length - 1 && !grid[row + 1][col].isVisited) {\n    unVisitedNeighbours.push(grid[row + 1][col]);\n  }\n\n  if (row < grid.length.length - 1 && !grid[row][col + 1].isVisited) {\n    unVisitedNeighbours.push(grid[row][col + 1]);\n  }\n\n  return unVisitedNeighbours;\n} // Backtracks from the finishNode to find the shortest path.\n// Only works after dijkstra is already called\n\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  nodesInShortestPathOrder = [];\n}\n\nfunction quickSortByDistance(array, start, end) {\n  if (start < end) {\n    let partitionIdx = partition(array, start, end);\n    quickSortByDistance(array, start, partitionIdx - 1);\n    quickSortByDistance(array, partitionIdx + 1, end);\n  }\n}\n\nfunction partition(array, start, end) {\n  let pivot = array[end].distance;\n  let partitionIdx = start;\n\n  for (let i = start; i < end; i++) {\n    if (array[i].distance <= pivot) {\n      swap(array, i, partitionIdx);\n      partitionIdx++;\n    }\n  }\n\n  swap(array, partitionIdx, end);\n  return partitionIdx;\n}\n\nfunction swap(array, idx1, idx2) {\n  const temp = array[idx1];\n  array[idx1] = array[idx2];\n  array[idx2] = temp;\n}\n\nfunction getNodes(grid) {\n  const nodes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    const currentRow = grid[i];\n\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/Users/andreimihai/Documents/proiecteDiverse/proiecte/pathfinding-visualizer/src/Algorithms/Dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","distance","visitedNodesInOrder","unvisitedNodes","getNodes","sortIt","length","quickSortByDistance","closestNode","shift","isWall","Number","POSITIVE_INFINITY","isVisited","push","updateUnvisitedNeighbours","node","unVisitedNeighbours","getUnvisitedNeighbours","i","neighbour","prevNode","row","col","getNodesInShortestPathOrder","nodesInShortestPathOrder","array","start","end","partitionIdx","partition","pivot","swap","idx1","idx2","temp","nodes","currentRow","j"],"mappings":"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","sourcesContent":["// Returns all nodes in the order in which they were visited.\n// Also makes nodes point back to their previous node,\n// allowing us to compute the shortest path by backtracking\n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n  let sortIt = true;\n\n  while (!!unvisitedNodes.length) {\n    if (sortIt) {\n      quickSortByDistance(unvisitedNodes, 0, unvisitedNodes.length - 1);\n    }\n\n    const closestNode = unvisitedNodes.shift();\n\n    // If the closest node is a wall, skip the node and the sorting\n    // since none of the distances have changed\n    if (closestNode.isWall) {\n      sortIt = false;\n      continue;\n    }\n\n    // If the closest node is at a distance of infinity,\n    // we no longer have a way to continue on, therefore we stop\n    if (closestNode.distance === Number.POSITIVE_INFINITY) {\n      return visitedNodesInOrder;\n    }\n\n    sortIt = true;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbours(grid, closestNode);\n  }\n}\n\nfunction updateUnvisitedNeighbours(grid, node) {\n  const unVisitedNeighbours = getUnvisitedNeighbours(grid, node);\n  for (let i = 0; i < unVisitedNeighbours.length; i++) {\n    const neighbour = unVisitedNeighbours[i];\n    neighbour.distance = node.distance + 1;\n    neighbour.prevNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbours(grid, node) {\n  const unVisitedNeighbours = [];\n  const { row, col } = node;\n\n  if (row > 0 && !grid[row - 1][col].isVisited) {\n    unVisitedNeighbours.push(grid[row - 1][col]);\n  }\n  if (col > 0 && !grid[row][col - 1].isVisited) {\n    unVisitedNeighbours.push(grid[row][col - 1]);\n  }\n  if (row < grid.length - 1 && !grid[row + 1][col].isVisited) {\n    unVisitedNeighbours.push(grid[row + 1][col]);\n  }\n  if (row < grid.length.length - 1 && !grid[row][col + 1].isVisited) {\n    unVisitedNeighbours.push(grid[row][col + 1]);\n  }\n\n  return unVisitedNeighbours;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works after dijkstra is already called\nexport function getNodesInShortestPathOrder(finishNode) {\n    nodesInShortestPathOrder = []\n}\n\nfunction quickSortByDistance(array, start, end) {\n  if (start < end) {\n    let partitionIdx = partition(array, start, end);\n    quickSortByDistance(array, start, partitionIdx - 1);\n    quickSortByDistance(array, partitionIdx + 1, end);\n  }\n}\n\nfunction partition(array, start, end) {\n  let pivot = array[end].distance;\n  let partitionIdx = start;\n\n  for (let i = start; i < end; i++) {\n    if (array[i].distance <= pivot) {\n      swap(array, i, partitionIdx);\n      partitionIdx++;\n    }\n  }\n\n  swap(array, partitionIdx, end);\n  return partitionIdx;\n}\n\nfunction swap(array, idx1, idx2) {\n  const temp = array[idx1];\n  array[idx1] = array[idx2];\n  array[idx2] = temp;\n}\n\nfunction getNodes(grid) {\n  const nodes = [];\n  for (let i = 0; i < grid.length; i++) {\n    const currentRow = grid[i];\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}\n"]},"metadata":{},"sourceType":"module"}