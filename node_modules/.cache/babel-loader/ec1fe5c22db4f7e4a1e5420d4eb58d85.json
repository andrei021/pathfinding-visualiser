{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Also makes nodes point back to their previous node,\n// allowing us to compute the shortest path by backtracking\n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    quickSortByDistance(unvisitedNodes, 0, unvisitedNodes.length - 1);\n    const closestNode = unvisitedNodes.shift(); // If the closest node is a wall, skip it\n\n    if (closestNode.isWall) continue; // If the closest node is at a distance of infinity,\n    // we no longer have a way to continue on, therefore we stop\n\n    if (closestNode.distance == Number.POSITIVE_INFINITY) {}\n  }\n}\n\nfunction quickSortByDistance(array, start, end) {\n  if (start < end) {\n    let partitionIdx = partition(array, start, end);\n    quickSortByDistance(array, start, partitionIdx - 1);\n    quickSortByDistance(array, partitionIdx + 1, end);\n  }\n}\n\nfunction partition(array, start, end) {\n  let pivot = array[end].distance;\n  let partitionIdx = start;\n\n  for (let i = start; i < end; i++) {\n    if (array[i].distance <= pivot) {\n      swap(array, i, partitionIdx);\n      partitionIdx++;\n    }\n  }\n\n  swap(array, partitionIdx, end);\n  return partitionIdx;\n}\n\nfunction swap(array, idx1, idx2) {\n  const temp = array[idx1];\n  array[idx1] = array[idx2];\n  array[idx2] = temp;\n}\n\nfunction getNodes(grid) {\n  nodes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    currentRow = grid[i];\n\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/Users/andreimihai/Documents/proiecteDiverse/proiecte/pathfinding-visualizer/src/Algorithms/Dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","distance","visitedNodesInOrder","unvisitedNodes","getNodes","length","quickSortByDistance","closestNode","shift","isWall","Number","POSITIVE_INFINITY","array","start","end","partitionIdx","partition","pivot","i","swap","idx1","idx2","temp","nodes","currentRow","j","push"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,SAASA,QAAT,CAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCC,UAAnC,EAA+C;AACpDD,EAAAA,SAAS,CAACE,QAAV,GAAqB,CAArB;AACA,QAAMC,mBAAmB,GAAG,EAA5B;AACA,QAAMC,cAAc,GAAGC,QAAQ,CAACN,IAAD,CAA/B;;AAEA,SAAO,CAAC,CAACK,cAAc,CAACE,MAAxB,EAAgC;AAC9BC,IAAAA,mBAAmB,CAACH,cAAD,EAAiB,CAAjB,EAAoBA,cAAc,CAACE,MAAf,GAAwB,CAA5C,CAAnB;AACA,UAAME,WAAW,GAAGJ,cAAc,CAACK,KAAf,EAApB,CAF8B,CAI9B;;AACA,QAAGD,WAAW,CAACE,MAAf,EAAuB,SALO,CAO9B;AACA;;AACA,QAAGF,WAAW,CAACN,QAAZ,IAAwBS,MAAM,CAACC,iBAAlC,EAAqD,CAAE;AACxD;AACF;;AAED,SAASL,mBAAT,CAA6BM,KAA7B,EAAoCC,KAApC,EAA2CC,GAA3C,EAAgD;AAC9C,MAAID,KAAK,GAAGC,GAAZ,EAAiB;AACf,QAAIC,YAAY,GAAGC,SAAS,CAACJ,KAAD,EAAQC,KAAR,EAAeC,GAAf,CAA5B;AACAR,IAAAA,mBAAmB,CAACM,KAAD,EAAQC,KAAR,EAAeE,YAAY,GAAG,CAA9B,CAAnB;AACAT,IAAAA,mBAAmB,CAACM,KAAD,EAAQG,YAAY,GAAG,CAAvB,EAA0BD,GAA1B,CAAnB;AACD;AACF;;AAED,SAASE,SAAT,CAAmBJ,KAAnB,EAA0BC,KAA1B,EAAiCC,GAAjC,EAAsC;AAClC,MAAIG,KAAK,GAAGL,KAAK,CAACE,GAAD,CAAL,CAAWb,QAAvB;AACA,MAAIc,YAAY,GAAGF,KAAnB;;AAEA,OAAI,IAAIK,CAAC,GAAGL,KAAZ,EAAmBK,CAAC,GAAGJ,GAAvB,EAA4BI,CAAC,EAA7B,EAAiC;AAC7B,QAAGN,KAAK,CAACM,CAAD,CAAL,CAASjB,QAAT,IAAqBgB,KAAxB,EAA+B;AAC3BE,MAAAA,IAAI,CAACP,KAAD,EAAQM,CAAR,EAAWH,YAAX,CAAJ;AACAA,MAAAA,YAAY;AACf;AACJ;;AAEDI,EAAAA,IAAI,CAACP,KAAD,EAAQG,YAAR,EAAsBD,GAAtB,CAAJ;AACA,SAAOC,YAAP;AACH;;AAED,SAASI,IAAT,CAAcP,KAAd,EAAqBQ,IAArB,EAA2BC,IAA3B,EAAiC;AAC7B,QAAMC,IAAI,GAAGV,KAAK,CAACQ,IAAD,CAAlB;AACAR,EAAAA,KAAK,CAACQ,IAAD,CAAL,GAAcR,KAAK,CAACS,IAAD,CAAnB;AACAT,EAAAA,KAAK,CAACS,IAAD,CAAL,GAAcC,IAAd;AACH;;AAED,SAASlB,QAAT,CAAkBN,IAAlB,EAAwB;AACtByB,EAAAA,KAAK,GAAG,EAAR;;AACA,OAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpB,IAAI,CAACO,MAAzB,EAAiCa,CAAC,EAAlC,EAAsC;AACpCM,IAAAA,UAAU,GAAG1B,IAAI,CAACoB,CAAD,CAAjB;;AACA,SAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAAU,CAACnB,MAA/B,EAAuCoB,CAAC,EAAxC,EAA4C;AAC1CF,MAAAA,KAAK,CAACG,IAAN,CAAWF,UAAU,CAACC,CAAD,CAArB;AACD;AACF;;AAED,SAAOF,KAAP;AACD","sourcesContent":["// Returns all nodes in the order in which they were visited.\n// Also makes nodes point back to their previous node,\n// allowing us to compute the shortest path by backtracking\n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    quickSortByDistance(unvisitedNodes, 0, unvisitedNodes.length - 1);\n    const closestNode = unvisitedNodes.shift();\n\n    // If the closest node is a wall, skip it\n    if(closestNode.isWall) continue;\n\n    // If the closest node is at a distance of infinity,\n    // we no longer have a way to continue on, therefore we stop\n    if(closestNode.distance == Number.POSITIVE_INFINITY) {}\n  }\n}\n\nfunction quickSortByDistance(array, start, end) {\n  if (start < end) {\n    let partitionIdx = partition(array, start, end);\n    quickSortByDistance(array, start, partitionIdx - 1);\n    quickSortByDistance(array, partitionIdx + 1, end);\n  }\n}\n\nfunction partition(array, start, end) {\n    let pivot = array[end].distance;\n    let partitionIdx = start;\n\n    for(let i = start; i < end; i++) {\n        if(array[i].distance <= pivot) {\n            swap(array, i, partitionIdx);\n            partitionIdx++;\n        }\n    }\n\n    swap(array, partitionIdx, end);\n    return partitionIdx;\n}\n\nfunction swap(array, idx1, idx2) {\n    const temp = array[idx1];\n    array[idx1] = array[idx2];\n    array[idx2] = temp;\n}\n\nfunction getNodes(grid) {\n  nodes = [];\n  for (let i = 0; i < grid.length; i++) {\n    currentRow = grid[i];\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}\n"]},"metadata":{},"sourceType":"module"}