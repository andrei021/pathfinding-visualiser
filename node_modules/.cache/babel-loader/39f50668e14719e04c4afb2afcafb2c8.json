{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Also makes nodes point back to their previous node,\n// allowing us to compute the shortest path by backtracking\n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    quickSortByDistance(unvisitedNodes, 0, unvisitedNodes.length - 1);\n  }\n}\n\nfunction quickSortByDistance(array, start, end) {\n  if (start < end) {\n    let partitionIdx = partition(array, start, end);\n    quickSortByDistance(array, start, partitionIdx - 1);\n    quickSortByDistance(array, partitionIdx + 1, end);\n  }\n}\n\nfunction partition(array, start, end) {\n  let pivot = array[end].distance;\n  let partitionIdx = start;\n\n  for (let i = start; i < end; i++) {\n    if (array[i].distance <= pivot) {\n      swap(array, i, partitionIdx);\n      partitionIdx++;\n    }\n  }\n\n  swap(array, partitionIdx, end);\n  return partitionIdx;\n}\n\nfunction swap(array, i, partitionIdx) {\n  const temp = array[i];\n}\n\nfunction getNodes(grid) {\n  nodes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    currentRow = grid[i];\n\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/Users/andreimihai/Documents/proiecteDiverse/proiecte/pathfinding-visualizer/src/Algorithms/Dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","distance","visitedNodesInOrder","unvisitedNodes","getNodes","length","quickSortByDistance","array","start","end","partitionIdx","partition","pivot","i","swap","temp","nodes","currentRow","j","push"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,SAASA,QAAT,CAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCC,UAAnC,EAA+C;AACpDD,EAAAA,SAAS,CAACE,QAAV,GAAqB,CAArB;AACA,QAAMC,mBAAmB,GAAG,EAA5B;AACA,QAAMC,cAAc,GAAGC,QAAQ,CAACN,IAAD,CAA/B;;AAEA,SAAO,CAAC,CAACK,cAAc,CAACE,MAAxB,EAAgC;AAC9BC,IAAAA,mBAAmB,CAACH,cAAD,EAAiB,CAAjB,EAAoBA,cAAc,CAACE,MAAf,GAAwB,CAA5C,CAAnB;AACD;AACF;;AAED,SAASC,mBAAT,CAA6BC,KAA7B,EAAoCC,KAApC,EAA2CC,GAA3C,EAAgD;AAC9C,MAAID,KAAK,GAAGC,GAAZ,EAAiB;AACf,QAAIC,YAAY,GAAGC,SAAS,CAACJ,KAAD,EAAQC,KAAR,EAAeC,GAAf,CAA5B;AACAH,IAAAA,mBAAmB,CAACC,KAAD,EAAQC,KAAR,EAAeE,YAAY,GAAG,CAA9B,CAAnB;AACAJ,IAAAA,mBAAmB,CAACC,KAAD,EAAQG,YAAY,GAAG,CAAvB,EAA0BD,GAA1B,CAAnB;AACD;AACF;;AAED,SAASE,SAAT,CAAmBJ,KAAnB,EAA0BC,KAA1B,EAAiCC,GAAjC,EAAsC;AAClC,MAAIG,KAAK,GAAGL,KAAK,CAACE,GAAD,CAAL,CAAWR,QAAvB;AACA,MAAIS,YAAY,GAAGF,KAAnB;;AAEA,OAAI,IAAIK,CAAC,GAAGL,KAAZ,EAAmBK,CAAC,GAAGJ,GAAvB,EAA4BI,CAAC,EAA7B,EAAiC;AAC7B,QAAGN,KAAK,CAACM,CAAD,CAAL,CAASZ,QAAT,IAAqBW,KAAxB,EAA+B;AAC3BE,MAAAA,IAAI,CAACP,KAAD,EAAQM,CAAR,EAAWH,YAAX,CAAJ;AACAA,MAAAA,YAAY;AACf;AACJ;;AAEDI,EAAAA,IAAI,CAACP,KAAD,EAAQG,YAAR,EAAsBD,GAAtB,CAAJ;AACA,SAAOC,YAAP;AACH;;AAED,SAASI,IAAT,CAAcP,KAAd,EAAqBM,CAArB,EAAwBH,YAAxB,EAAsC;AAClC,QAAMK,IAAI,GAAGR,KAAK,CAACM,CAAD,CAAlB;AACH;;AAED,SAAST,QAAT,CAAkBN,IAAlB,EAAwB;AACtBkB,EAAAA,KAAK,GAAG,EAAR;;AACA,OAAK,IAAIH,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGf,IAAI,CAACO,MAAzB,EAAiCQ,CAAC,EAAlC,EAAsC;AACpCI,IAAAA,UAAU,GAAGnB,IAAI,CAACe,CAAD,CAAjB;;AACA,SAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAAU,CAACZ,MAA/B,EAAuCa,CAAC,EAAxC,EAA4C;AAC1CF,MAAAA,KAAK,CAACG,IAAN,CAAWF,UAAU,CAACC,CAAD,CAArB;AACD;AACF;;AAED,SAAOF,KAAP;AACD","sourcesContent":["// Returns all nodes in the order in which they were visited.\n// Also makes nodes point back to their previous node,\n// allowing us to compute the shortest path by backtracking\n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    quickSortByDistance(unvisitedNodes, 0, unvisitedNodes.length - 1);\n  }\n}\n\nfunction quickSortByDistance(array, start, end) {\n  if (start < end) {\n    let partitionIdx = partition(array, start, end);\n    quickSortByDistance(array, start, partitionIdx - 1);\n    quickSortByDistance(array, partitionIdx + 1, end);\n  }\n}\n\nfunction partition(array, start, end) {\n    let pivot = array[end].distance;\n    let partitionIdx = start;\n\n    for(let i = start; i < end; i++) {\n        if(array[i].distance <= pivot) {\n            swap(array, i, partitionIdx);\n            partitionIdx++;\n        }\n    }\n\n    swap(array, partitionIdx, end);\n    return partitionIdx;\n}\n\nfunction swap(array, i, partitionIdx) {\n    const temp = array[i];\n}\n\nfunction getNodes(grid) {\n  nodes = [];\n  for (let i = 0; i < grid.length; i++) {\n    currentRow = grid[i];\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}\n"]},"metadata":{},"sourceType":"module"}