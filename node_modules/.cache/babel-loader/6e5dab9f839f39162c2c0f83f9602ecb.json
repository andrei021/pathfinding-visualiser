{"ast":null,"code":"// Returns all nodes in the order in which they were visited. \n// Also makes nodes point back to their previous node, \n// allowing us to compute the shortest path by backtracking \n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n  }\n}\nsortNodesByDistance();\n\nfunction getNodes(grid) {\n  nodes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    currentRow = grid[i];\n\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/Users/andreimihai/Documents/proiecteDiverse/proiecte/pathfinding-visualizer/src/Algorithms/Dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","distance","visitedNodesInOrder","unvisitedNodes","getNodes","length","sortNodesByDistance","nodes","i","currentRow","j","push"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAO,SAASA,QAAT,CAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCC,UAAnC,EAA+C;AAClDD,EAAAA,SAAS,CAACE,QAAV,GAAqB,CAArB;AACA,QAAMC,mBAAmB,GAAG,EAA5B;AACA,QAAMC,cAAc,GAAGC,QAAQ,CAACN,IAAD,CAA/B;;AAEA,SAAM,CAAC,CAACK,cAAc,CAACE,MAAvB,EAA+B;AAC3BC,IAAAA,mBAAmB,CAACH,cAAD,CAAnB;AACH;AACJ;AAEDG,mBAAmB;;AAEnB,SAASF,QAAT,CAAkBN,IAAlB,EAAwB;AACpBS,EAAAA,KAAK,GAAG,EAAR;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGV,IAAI,CAACO,MAAxB,EAAgCG,CAAC,EAAjC,EAAqC;AACjCC,IAAAA,UAAU,GAAGX,IAAI,CAACU,CAAD,CAAjB;;AACA,SAAI,IAAIE,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGD,UAAU,CAACJ,MAA9B,EAAsCK,CAAC,EAAvC,EAA2C;AACvCH,MAAAA,KAAK,CAACI,IAAN,CAAWF,UAAU,CAACC,CAAD,CAArB;AACH;AACJ;;AAED,SAAOH,KAAP;AACH","sourcesContent":["// Returns all nodes in the order in which they were visited. \n// Also makes nodes point back to their previous node, \n// allowing us to compute the shortest path by backtracking \n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n    startNode.distance = 0;\n    const visitedNodesInOrder = [];\n    const unvisitedNodes = getNodes(grid);\n\n    while(!!unvisitedNodes.length) {\n        sortNodesByDistance(unvisitedNodes);\n    }\n}\n\nsortNodesByDistance()\n\nfunction getNodes(grid) {\n    nodes = [];\n    for(let i = 0; i < grid.length; i++) {\n        currentRow = grid[i];\n        for(let j = 0; j < currentRow.length; j++) {\n            nodes.push(currentRow[j]);\n        }\n    }\n\n    return nodes;\n} \n"]},"metadata":{},"sourceType":"module"}