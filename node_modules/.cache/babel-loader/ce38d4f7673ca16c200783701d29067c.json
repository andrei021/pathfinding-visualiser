{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Also makes nodes point back to their previous node,\n// allowing us to compute the shortest path by backtracking\n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n  let sortIt = true;\n\n  while (!!unvisitedNodes.length) {\n    if (sortIt) {\n      quickSortByDistance(unvisitedNodes, 0, unvisitedNodes.length - 1);\n    }\n\n    const closestNode = unvisitedNodes.shift(); // If the closest node is a wall, skip the node and the sorting\n    // since none of the distances have changed\n\n    if (closestNode.isWall) {\n      sortIt = false;\n      continue;\n    } // If the closest node is at a distance of infinity,\n    // we no longer have a way to continue on, therefore we stop\n\n\n    if (closestNode.distance === Number.POSITIVE_INFINITY) {\n      return visitedNodesInOrder;\n    }\n\n    sortIt = true;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbours(grid, closestNode);\n  }\n}\n\nfunction updateUnvisitedNeighbours(grid, node) {\n  const unVisitedNeighbours = getUnvisitedNeighbours(grid, node);\n}\n\nfunction getUnvisitedNeighbours(grid, node) {\n  const unVisitedNeighbours = [];\n  const {\n    row,\n    col\n  } = node;\n\n  if (row > 0 && !grid[row - 1][col].isVisited) {\n    unVisitedNeighbours.push(grid[row - 1][col]);\n  }\n\n  if (row > 0 && !grid[row - 1][col].isVisited) {\n    unVisitedNeighbours.push(grid[row - 1][col]);\n  }\n\n  if (row > 0 && !grid[row - 1][col].isVisited) {\n    unVisitedNeighbours.push(grid[row - 1][col]);\n  }\n\n  if (row > 0 && !grid[row - 1][col].isVisited) {\n    unVisitedNeighbours.push(grid[row - 1][col]);\n  }\n}\n\nfunction quickSortByDistance(array, start, end) {\n  if (start < end) {\n    let partitionIdx = partition(array, start, end);\n    quickSortByDistance(array, start, partitionIdx - 1);\n    quickSortByDistance(array, partitionIdx + 1, end);\n  }\n}\n\nfunction partition(array, start, end) {\n  let pivot = array[end].distance;\n  let partitionIdx = start;\n\n  for (let i = start; i < end; i++) {\n    if (array[i].distance <= pivot) {\n      swap(array, i, partitionIdx);\n      partitionIdx++;\n    }\n  }\n\n  swap(array, partitionIdx, end);\n  return partitionIdx;\n}\n\nfunction swap(array, idx1, idx2) {\n  const temp = array[idx1];\n  array[idx1] = array[idx2];\n  array[idx2] = temp;\n}\n\nfunction getNodes(grid) {\n  nodes = [];\n\n  for (let i = 0; i < grid.length; i++) {\n    currentRow = grid[i];\n\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}","map":{"version":3,"sources":["/Users/andreimihai/Documents/proiecteDiverse/proiecte/pathfinding-visualizer/src/Algorithms/Dijkstra.js"],"names":["dijkstra","grid","startNode","finishNode","distance","visitedNodesInOrder","unvisitedNodes","getNodes","sortIt","length","quickSortByDistance","closestNode","shift","isWall","Number","POSITIVE_INFINITY","isVisited","push","updateUnvisitedNeighbours","node","unVisitedNeighbours","getUnvisitedNeighbours","row","col","array","start","end","partitionIdx","partition","pivot","i","swap","idx1","idx2","temp","nodes","currentRow","j"],"mappings":"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","sourcesContent":["// Returns all nodes in the order in which they were visited.\n// Also makes nodes point back to their previous node,\n// allowing us to compute the shortest path by backtracking\n// from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  const visitedNodesInOrder = [];\n  const unvisitedNodes = getNodes(grid);\n  let sortIt = true;\n\n  while (!!unvisitedNodes.length) {\n    if (sortIt) {\n      quickSortByDistance(unvisitedNodes, 0, unvisitedNodes.length - 1);\n    }\n\n    const closestNode = unvisitedNodes.shift();\n\n    // If the closest node is a wall, skip the node and the sorting\n    // since none of the distances have changed\n    if (closestNode.isWall) {\n      sortIt = false;\n      continue;\n    }\n\n    // If the closest node is at a distance of infinity,\n    // we no longer have a way to continue on, therefore we stop\n    if (closestNode.distance === Number.POSITIVE_INFINITY) {\n      return visitedNodesInOrder;\n    }\n\n    sortIt = true;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbours(grid, closestNode);\n  }\n}\n\nfunction updateUnvisitedNeighbours(grid, node) {\n    const unVisitedNeighbours = getUnvisitedNeighbours(grid, node);\n}\n\nfunction getUnvisitedNeighbours(grid, node) {\n    const unVisitedNeighbours = [];\n    const {row, col} = node;\n\n    if(row > 0 && !grid[row - 1][col].isVisited) {\n        unVisitedNeighbours.push(grid[row - 1][col]);\n    }\n    if(row > 0 && !grid[row - 1][col].isVisited) {\n        unVisitedNeighbours.push(grid[row - 1][col]);\n    }\n    if(row > 0 && !grid[row - 1][col].isVisited) {\n        unVisitedNeighbours.push(grid[row - 1][col]);\n    }\n    if(row > 0 && !grid[row - 1][col].isVisited) {\n        unVisitedNeighbours.push(grid[row - 1][col]);\n    }\n}\n\nfunction quickSortByDistance(array, start, end) {\n  if (start < end) {\n    let partitionIdx = partition(array, start, end);\n    quickSortByDistance(array, start, partitionIdx - 1);\n    quickSortByDistance(array, partitionIdx + 1, end);\n  }\n}\n\nfunction partition(array, start, end) {\n  let pivot = array[end].distance;\n  let partitionIdx = start;\n\n  for (let i = start; i < end; i++) {\n    if (array[i].distance <= pivot) {\n      swap(array, i, partitionIdx);\n      partitionIdx++;\n    }\n  }\n\n  swap(array, partitionIdx, end);\n  return partitionIdx;\n}\n\nfunction swap(array, idx1, idx2) {\n  const temp = array[idx1];\n  array[idx1] = array[idx2];\n  array[idx2] = temp;\n}\n\nfunction getNodes(grid) {\n  nodes = [];\n  for (let i = 0; i < grid.length; i++) {\n    currentRow = grid[i];\n    for (let j = 0; j < currentRow.length; j++) {\n      nodes.push(currentRow[j]);\n    }\n  }\n\n  return nodes;\n}\n"]},"metadata":{},"sourceType":"module"}